<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Drogon 框架一、Drogon 框架是什么 Drogon 是一个基于 C++17&amp;#x2F;20 的 Http 应用框架，使用 Drogon 可以方便的使用C++ 构建各种类型的 Web 应用服务端程序。  二、Windows 平台 Drogon 框架的安装2.1 vcpkg 的安装123git"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Drogon 框架一、Drogon 框架是什么 Drogon 是一个基于 C++17&amp;#x2F;20 的 Http 应用框架，使用 Drogon 可以方便的使用C++ 构建各种类型的 Web 应用服务端程序。  二、Windows 平台 Drogon 框架的安装2.1 vcpkg 的安装123git"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: John Doe","link":"Link: ","source":"Source: Hexo","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'Hexo',
  postAI: '',
  pageFillDescription: 'Drogon 框架, 一、Drogon 框架是什么, 二、Windows 平台 Drogon 框架的安装, 2.1 vcpkg 的安装, 三、Drogon 框架基本使用, 四、控制器, 4.1 控制器的概念, 4.2 控制器的创建, 4.3 控制器的生命周期, 4.4 控制器的分类, 4.3.1 HttpSimpleController, 4.3.2 HttpController, 4.3.3 WebSocketController, 五、中间件和过滤器, 5.1 中间件和过滤器的概念, 5.2 内置中间件和过滤器, 5.3 自定义中间件和过滤器, 5.3.1 中间件的定义, 5.3.2 过滤器的定义, 5.4 中间件单独测试, 5.5 过滤器单独测试, 5.6 中间件和过滤器混合使用, 5.7 中间件和过滤器的区别, 六、视图, 6.1 视图的概念, 6.2 drogon 的 csp 的规则, 6.3 视图的使用, 6.4 简单的例子, 七、会话, 7.1 会话的概念, 7.2 会话的对象, 7.3会话的例子, 八、数据库, 九、插件, 9.1 插件的概念, 9.2 插件的创建定义, 十、配置文件, 十一、drogon_ctl 命令, 十二、性能测试, 十三、Redis, 十四、测试框架框架一框架是什么是一个基于的应用框架使用可以方便的使用构建各种类型的应用服务端程序二平台框架的安装的安装执行完上述命令后在当前文件夹下可以看到程序将当前所在目录添加到系统环境变量打开执行以下命令即可看到的相关信息比如以下输出安装框架切换目录到所在目录并打开执行以下命令即可看到一些输出信息比如可以看到一些三方库依赖都会被安装接下来需要执行命令来安装更多的特性请运行查看安装完之后需要将所在的路径添加到系统环境变量之后重启执行命令可以看到以下输出可以看到不支持等库如果想要支持上述库可以使用先查看相关信息再执行相关命令比如来安装库其他库安装同上三框架基本使用通过上述安装后我们安装了工具通过该工具我们可以创建一个模板工程执行命令其中指代项目的名称我们在文件夹下执行上述命令即可在文件夹下生成一个名为的工程文件夹下生成相关的构建文件和文件夹文件夹的名字就反应了其用途比如代表控制器代表过滤器代表插件文件夹就是构建输出目录通过上述方式可以更好的实现项目管理我们看一下文件的内容内容如下或者是修改文件在之前添加下面代码这样的话直接执行下述命令即可执行完毕后可执行程序在文件夹下被成功生成根目录默认值是也就是程序运行的当前路径即可执行程序所在的目录依据该规则我们可以在文件夹下新建文件文件内容如下运行可执行程序在浏览器输入地址或者可以看到如下响应上述是一个最简单的例子一些细节等待后续介绍四控制器控制器的概念在开发中控制器是设计模式中的一个核心组件它的主要职责是接收用户的请求处理请求通常调用模型进行业务逻辑处理并决定返回什么样的响应通常是选择一个视图或直接返回数据框架已经帮我们处理好网络传输协议的解析等等细节我们只需要关注控制器的逻辑即可每一个控制器对象可以有一个或者多个处理函数一般称为函数的接口简单控制器对象只有一个处理接口所有的请求都通过该接口进行处理控制器的创建通过我们就可以创建控制器上述介绍中我们通过创建了一个名为的项目在其中有文件夹切换到文件夹执行命令之后会为我们创建两个和文件查看文件其内容如下所示可以看到继承了称为简单控制器这个函数通过关键字可以得知这是重写的父类的虚函数是请求的对象由包裹是框架传给控制器的回调函数对象控制器生成应答对象也通过智能指针包裹后通过把该对象传给然后框架会帮你把响应内容发送给浏览器简单控制器的请求处理函数其函数列表没有可以接收参数的位置我们可以在函数体内部通过去获取请求携带的参数控制器的生命周期注册到框架的控制器最多只会有一个实例在整个应用运行期间都不会销毁所以用户可以在控制器类中声明和使用成员变量注意控制器的被调用时是在多线程环境下的当框架的线程数配置成大于的值时如果需要访问非临时变量请做好并发保护工作比如说我们使用控制器可以注册多个请求处理函数我们的框架的线程大于的时候每个线程都可能调用同一控制器的不同的时间线程线程线程线程空闲空闲空闲空闲所有的这些调用都是在同一个控制器实例上进行的如果我们在控制器中定义了一个成员变量在不同的中对这个成员变量进行了修改就会导致并发问题可以使用等做好并发保护控制器的分类我们可以通过命令去快速生成基于的自定义源文件其中表示该参数是可选的表示生成继承的控制器类表示命名空间添加该参数会在生成的控制器类外添加一个名称为的命名空间可以将替换成你想要的名称我们通过命令创建一个名称为的控制器执行完命令后在命令执行的目录下可以看到新增的和文件下面查看一下这两个文件的内容每个类只能定义一个请求处理函数而且是通过重写父类虚函数定义的可以看到中有三个宏和以及从路径到处理函数的路由或称映射由宏完成可以用宏添加多重路径映射所有语句应夹在和宏语句之间宏第一个参数是映射的路径路径后面的参数是对这个路径的约束目前支持两种约束一种是类型表示该路径允许使用的方法可以配置零个或多个一种是类的名字这种对象执行特定的过滤操作也可以配置个或多个两种类型没有顺序要求框架会处理好类型的匹配称为过滤器关于过滤器等待后续介绍用户可以把同一个注册到多个路径上也可以在同一个路径上注册多个通过区分这句话的意思就是说我们可以在一个中添加多个宏比如下面代码在一个中注册多个表明上述路由都由该控制器进行处理我们可以在处理函数中根据请求进行不同的处理在同一个路径上注册多个是在不同的中添加相同的具体是通过不同的请求方法进行处理但是如果不小心添加了相同的和请求方法比如在多个中出现这个时候就是调用后构造的控制器的处理函数控制器实例化的顺序目前猜测是按照控制器名称代表字符串的大小进行实例化名称代表的字符串越大实例化越晚我们通过命令创建一个名称为的控制器执行完命令后在命令执行的目录下可以看到新增的和文件下面查看一下这两个文件的内容我们编辑以下这两个文件再进行阐述修改如下添加路径映射自定义请求处理函数修改如下每个类可以定义多个请求处理函数由于函数数目可以任意多所以通过虚函数重载是不现实的我们需要把本身而不是类注册到框架里去从路径到处理函数的映射由宏完成可以用宏或宏添加多重路径映射所有和语句应夹在和宏语句之间宏会在路径映射中自动把命名空间和类名作为路径的前缀所以本例子中函数被注册到了路径上函数被注册到了路径上后面的约束跟的宏类似不再赘述如果使用了自动的前缀访问地址要包含命名空间和类名此例中要使用或者来访问宏的作用与前者几乎一样除了它不会自动添加任何前缀即这个宏注册的路径是一个绝对路径通过上述例子我们可以看到提供了更为灵活的路径映射功能并且可以注册多个处理函数我们可以将一类功能放在一个类里另外可以看到宏提供了参数映射的方法我们可以把路径上的参数映射到函数的参数表里由参数的数码对应形参的位置非常方便常见的可以由字符串类型转换的类型都可以作为参数如等等框架基于模板的类型推断会自动帮你转换类型非常方便如果路径参数和函数参数不匹配或者是不能进行转换框架会报错注意左值引用必须是类型这点要求是因为框架传递过来的数据是临时值如果使用非常量左值引用代表我们可以修改这个临时值这会引发未定义行为是不允许的编译不会通过同一个路径还可以注册多次相互之间通过区分这是合法的并且是的通常做法比如路径参数的占位符有多种写法表示这个路径参数映射到处理函数的对应位置上路径上的位置就是函数参数的位置中间有个数字的表示映射到数字指定的处理函数参数上中间的字符串没有实际作用但可以提高程序的可读性与等价冒号前的数字表示位置后面的字符串没有实际作用但可以提高程序的可读性与等价路径匹配大小写不敏感参数名字大小写敏感参数值大小写保持原貌就是说我们的大小写不敏感但是其传递的参数大小写敏感我们在请求处理函数中通过请求对象去获取参数数据的时候注意保持大小写一致通过前面的叙述我们知道路径上的参数和问号后面的请求参数都可以映射到处理函数的参数列表里目标参数的类型需要满足如下条件必须是值类型常左值引用或非右值引用中的一种不能是非的左值引用推荐使用右值引用这样用户可以随意处置它等基础类型都可以作为参数类型任何可以使用操作符赋值的类型顾名思义用于处理逻辑是基于的一种长连接方案在建立之初有一次格式的请求和应答交换建立完成后所有的消息在上传输消息由固定的格式包装但消息的内容和收发次序没有任何要求完全由用户定义我们通过命令去创建基于的自定义源文件执行完命令后在命令执行的目录下可以看到和文件被创建下面查看以下这两个源文件的内容我们简单编辑以下文件的内容并进行测试修改以下部分修改发送消息给对端接收到新连接后打印自己和对端的地址处理连接断开首先在这个例子中通过宏把这个控制器注册到了路径上宏的用法跟之前介绍的其他控制器的宏类似也可以注册路径并且附带若干中间件和过滤器由于在框架中单独处理所以它可以和前两种控制器的路径重复而不会相互影响本例中通过创建的生成的三个函数分别是处理新消息处理新连接处理连接断开这里只是做了简单的打印来验证函数是否被调用在建立之后被调用是客户端发来的建立请求这时候框架已经返回了用户可以做的是通过获得一些额外信息比如之类是这个对象的智能指针常用的接口等待后续介绍在收到新的消息之后被调用消息存储在变量里注意这个是完整的消息净荷框架已经做完了消息的解封包和解码等工作用户直接处理消息本身即可在连接关闭之后调用用户可以做一些收尾工作使用工具进行测试点击之后在服务端可以看到函数被调用打印了本机和对端的地址点击之后可以看到输入框的消息被成功发送保活机制心跳检测稍后写五中间件和过滤器中间件和过滤器的概念中间件和过滤器可以帮助用户提高编程效率在的例子中方法我们是作为获取用户信息使用的所以在返回用户信息之前应该先校验用户是否登录避免非法用户获取信息我们把这个逻辑写在方法里当然是可以的但是很显然校验用户登录属于通用逻辑很多接口都将用到应该把它单独提取出来再配置到调用之前这就是的作用的中间件采用了洋葱圈模型框架做完路径匹配后会依次调用注册到该路径上的中间件在每个中间件中用户可以选择拦截或放行请求并添加前置后置处理逻辑如果有一个中间件拦截了请求该请求将不会继续深入洋葱圈内层对应的也不会被调用但是仍然会通过外层中间件的后置处理逻辑过滤器实际上是省略后置操作的中间件经过进一步的包装后暴露给用户中间件和过滤器可以在注册路径时混合使用注意如果中间件过滤器定义在命名空间里注册时必须把命名空间写全内置中间件和过滤器中内置了以下常用的过滤器只放行内网发来的请求否则返回页面只放行本机或者发来的请求否则返回页面上述两种内置的过滤器也是以字符串的形式给定的比如这种写法名称不对或过滤器不存在框架会报的错误自定义中间件和过滤器中间件的定义用户可以自定义中间件需要继承类模板模板类型就是子类类型比如我们自定义中间件如下记得中间件要写构造函数默认即可如果忘记定义构造函数则在注册路径时会出现找不到中间件的错误可以看到自定义的中间件类继承类并重写父类虚函数该函数有三个参数分别是表示请求进入内层的回调函数调用该函数意味着继续深入洋葱圈内层调用下一个中间件或最终调用时接受另一个函数作为参数当从洋葱圈内层返回时该函数会被调用并传入内层返回的返回上层的回调函数调用该函数意味着返回洋葱圈上层若跳过只调用意味着拦截该请求直接返回上层过滤器的定义用户可以自定义过滤器需要继承类模板模板类型就是子类类型比如我们想做一个就可以定义如下上述过滤器是我们通过执行命令创建来的可以看到继承并且重写了父类的虚函数该虚函数有三个参数分别是请求过滤器回调函数当过滤器判定请求不合法时通过这个回调把特定的响应返回给浏览器过滤器链回调函数当过滤器判定请求合法时通过这个回调告诉调用下一个过滤器或者最终的中间件单独测试我们定义一个名为的中间件以下是其对应的文件内容判断是否是跨域请求我们再定义一个简单的控制器以下是其对应的文件内容我们在这里注册路径并添加中间件可以看到我们在控制器注册路径并添加了中间件这样的话框架在做完匹配以后会依次调用注册在该路径上的中间件使用进行测试可以看到我们没有在请求头中添加字段服务端响应如下可以看到服务端调用了函数并触发了其回调函数函数注册的回调函数中参数由控制器的中调用函数返回而来回调函数调用函数将响应返回给客户端在请求头中添加字段和其对应的值可以看到服务端返回了的响应这是因为中间件直接调用了函数返回响应给客户端过滤器单独测试我们定义一个名为的过滤器以下是其对应的文件内容依旧使用上述中间件单独测试中的控制器修改其路径注册为使用进行测试可以看到我们在请求头中没有添加字段服务端在请求头中没有添加的字段服务端直接调用函数会调用最终的也就是控制器的请求处理函数由控制器发送响应给客户端我们在请求头添加字段和对应的值可以看到服务端返回了的状态码也就是调用了函数通过该回调函数将响应发送给客户端中间件和过滤器混合使用中间件和过滤器的区别文档中介绍过滤器实际上是省略后置操作的中间件中间件过滤器注意到当使用中间件的时候我们在函数中对控制器返回的响应进行了进一步的修改添加了和两个字段表现了中间件的一种后置操作而过滤器就没有这种功能过滤器的函数在判定请求不合法时直接返回响应给客户端而且无法通过回调函数获取控制器返回的响应没有后置操作特性中间件过滤器是否支持前置检查是是是否支持后置操作是通过回调否能否修改响应能在回调中不能能否添加动态响应头如能基于原始不能除非控制器配合执行时机路由匹配后控制器执行前后路由匹配后控制器执行前六视图视图的概念虽然目前前端渲染技术大行其道使后端应用服务只需要返回相应数据给前端即可不过一个好的框架还是应该提供后端渲染技术使服务端程序可以动态生成页面视图可以帮助使用者生成这些页面顾名思义它只负责做跟展示相关的工作而复杂的业务逻辑都应该交给控制器完成最早的应用程序都是把嵌入到程序编码里达到动态生成页面的目的不过这样做有效率低不直观等诸多缺点于是出现了诸如等语言反其道而行之把程序代码嵌入到页面里采用的当然是后一种方案不过很明显由于是编译执行的我们需要把这种嵌入了代码的页面转换成源程序才能编译进应用程序所以定义了自己专门的描述语言使用命令行工具可以把文件转换成源文件以供编译的的规则的方案很简单我们用特殊的标记符号把代码嵌入到页面里就可以了夹在标签和之间的内容被视为需要引用的头文件部分这里只能写入语句如不过很多常见的头文件都自动包含了用户基本上用不到这个标签夹在标签和之间的所有内容都被视为的代码如的代码一般都会原封不动的转移到目标源文件中除了下面两种特殊标记代表控制器传过来的变量类型是可以从中获取需要的内容代表表示页面内容的流对象可以把需要显示的内容通过操作符显示在页面上夹在标签和之间的内容被认为是变量名字会以这个名字为从控制器传过来的数据里找到对应的变量并把它输出到页面的对应位置变量名字前后的空格会被省略和不要分行写同时出于性能考虑只支持三种字符串数据类型和因为输出时涉及数据类型判断过多类型会导致过多的条件语句其他数据类型请用上面提到的方式输出或者将需要输出的变量以类型存入中夹在标签和之间的内容被认为是程序里变量的名字或表达式而不是控制器传过来的数据的会把该变量的内容或表达式的值输出到页面的对应位置容易知道等效于只是前者更为简单直观同样的两个标签不要分行写夹在标签和之间的内容被认为是子视图的名字框架会找到相应的子视图并把它的内容填充到该标签所在位置视图名字前后的空格会被忽略同时和不要分行写子视图和父视图共用控制器的数据可以多级嵌套但不要循环嵌套夹在标签和之间的内容被认为是布局的名字框架会找到相应的布局并把本视图的内容填充到该布局的某个位置在布局中由占位符标定该位置布局名字前后的空格会被忽略同时和不要分行写可以多级嵌套但不要循环嵌套视图的使用这是的函数原型通过注释可以看到参数指代文件的名称是展现在页面中的数据该参数有默认参数可以看到控制器不需要引入视图的头文件二者通过变量进行关联控制器和视图之间实现了很好的解耦由命令生成的项目中会默认生成一个文件夹我们在文件夹下新建文件重新执行执行或者这取决于你使用的是什么构建工具执行该命令的时候可以看到控制台的输出例如框架根据文件夹下的文件生成同名的和文件这一过程是由框架自动完成的具体可以看一下生成的其中包含如下命令是项目的名称需要知道这个名称以便将生成的源文件正确地关联到你的可执行文件或库的构建目标中它会将生成的文件添加到这个目标的源文件列表里是内置变量指向当前文件所在的路径也是内置变量指向与当前文件对应的构建目录上述命令会从目录下递归的查找文件并且生成同名的和文件存放在当前构建目录下防止污染源代码树简单的例子我们现在做一个简单的例子把浏览器发来的请求参数显示在返回的页面中这里直接用定义在文件中在调用方法之前加入如下代码上面这段代码把一个表达式注册到路径上获取请求的参数传递给视图显示在工程文件夹下新建文件内容如下就是从控制器中传入的变量比如是中的第二个对象重新执行命令并执行相应的构建命令可以看到在当前构建目录下会生成和文件之后运行可执行程序在浏览器或其他客户端输入记设置你的程序中服务实际监听的端口即可看到如下界面七会话会话的概念会话是应用的重要概念用于在服务端保存客户端的状态一般和浏览器的配合提供了对会话的支持默认关闭会话选择你也可以通过如下接口关闭或打开都是通过单例调用参数代表了会话失效的时间单位是秒框架默认值是即如果用户分钟以上没有访问应用则他对应的会话就失效了设置为表示将在整个生存期保留用户的会话打开会话特性前请确定你的客户端支持否则会为每次不含的请求创建新的会话这会白白浪费内存和计算资源框架的会话支持默认是关闭的如果不开启会话支持框架只是简单的处理请求而不会分配额外的内存会话的对象的会话对象类型是它和非常类似可以通过关键字存取任意类型的对象支持并发读写框架会把会话对象放到对象里传递给用户用户可以通过类的如下接口获取对象获得的是对象的智能指针通过它可以存取各种对象会话的例子第一个接口设置会话值获取当前会话对象保存到会话中请求第二个接口读取会话值上述代码注册了两个路径和下面我们通过去访问以下这两个可以看到服务端返回的响应中响应头有字段响应体也是我们服务端锁返回的数据可以看到在请求头中设置了字段是通过请求服务端返回的服务端使用通过查找到该会话成功获取到该会话设置的数据八数据库九插件插件的概念插件可以帮助用户构建复杂的应用在中所有的插件都由框架根据配置文件统一构建并安装到应用程序中中的插件都是单实例的用户可以用插件实现任何他们想要的功能插件的创建定义我们可以使用命令去创建插件十配置文件十一命令十二性能测试十三十四测试框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-03 11:27:24',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 8.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="Random Post" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="Console" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">Interaction</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">Interests</div><span class="author-content-item-title">Find your area of interest</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%A7%8B/" style="font-size: 1.05rem;">开始<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>Articles</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/02/"><span class="card-archive-list-date">February 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="Toggle Display Mode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="Toggle Sidebar"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="Toggle Music"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="Toggle"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2026-02-09T01:50:17.589Z" title="Created 2026-02-09 09:50:17">2026-02-09</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-11-03T03:27:24.969Z" title="Updated 2025-11-03 11:27:24">2025-11-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/"><header><h1 id="CrawlerTitle" itemprop="name headline">No title</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2026-02-09T01:50:17.589Z" title="Created 2026-02-09 09:50:17">2026-02-09</time><time itemprop="dateCreated datePublished" datetime="2025-11-03T03:27:24.969Z" title="Updated 2025-11-03 11:27:24">2025-11-03</time></header><h2 id="Drogon-框架"><a href="#Drogon-框架" class="headerlink" title="Drogon 框架"></a>Drogon 框架</h2><h3 id="一、Drogon-框架是什么"><a href="#一、Drogon-框架是什么" class="headerlink" title="一、Drogon 框架是什么"></a>一、Drogon 框架是什么</h3><ul>
<li>Drogon 是一个基于 C++17&#x2F;20 的 Http 应用框架，使用 Drogon 可以方便的使用C++ 构建各种类型的 Web 应用服务端程序。</li>
</ul>
<h3 id="二、Windows-平台-Drogon-框架的安装"><a href="#二、Windows-平台-Drogon-框架的安装" class="headerlink" title="二、Windows 平台 Drogon 框架的安装"></a>二、Windows 平台 Drogon 框架的安装</h3><h4 id="2-1-vcpkg-的安装"><a href="#2-1-vcpkg-的安装" class="headerlink" title="2.1 vcpkg 的安装"></a>2.1 vcpkg 的安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/microsoft/vcpkg</span><br><span class="line"><span class="built_in">cd</span> vcpkg</span><br><span class="line">./bootstrap<span class="literal">-vcpkg</span>.bat</span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，在当前vcpkg文件夹下可以看到 vcpkg.exe 程序。</p>
<p>将当前 vcpkg.exe 所在目录添加到系统环境变量，打开 PowerShell，执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg.exe <span class="literal">--version</span></span><br></pre></td></tr></table></figure>

<p>即可看到 vcpkg 的相关信息，比如以下输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030174023781.png" alt="image-20251030174023781"></p>
<p>2.2 安装 Drogon 框架</p>
<p>切换目录到 vcpkg.exe 所在目录并打开 PowerShell，执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install drogon:x64<span class="literal">-windows</span></span><br></pre></td></tr></table></figure>

<p>即可看到一些输出信息，比如，可以看到一些三方库依赖都会被安装</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030175620337.png" alt="image-20251030175620337"></p>
<p>接下来需要执行 vcpkg install drogon[ctl]:x64-windows –recurse 命令来安装 drogon_ctl，更多的特性请运行 vcpkg search drogon 查看.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030174744553.png" alt="image-20251030174744553"></p>
<p>安装完 drogon_ctl 之后，需要将 drogon_ctl 所在的路径添加到系统环境变量，之后重启 PowerShell 执行命令<code>drogon_ctl version</code>，可以看到以下输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030180829593.png" alt="image-20251030180829593"></p>
<p>可以看到 drogon 不支持 postgresql、sqlite3、brotli、hiredis等库，如果想要 drogon 支持上述库，可以使用 vcpkg search drogon 先查看相关信息，再执行相关命令，比如</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install drogon[<span class="type">redis</span>]:x64<span class="literal">-windows</span> <span class="literal">--recurse</span></span><br></pre></td></tr></table></figure>

<p>来安装 hiredis 库，其他库安装同上。</p>
<h3 id="三、Drogon-框架基本使用"><a href="#三、Drogon-框架基本使用" class="headerlink" title="三、Drogon 框架基本使用"></a>三、Drogon 框架基本使用</h3><p>通过上述安装后，我们安装了 drogon_ctl 工具，通过该工具我们可以创建一个模板工程，执行命令<code>drogon_ctl create project project_name</code>，其中 project_name 指代项目的名称。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030181728937.png" alt="image-20251030181728937"></p>
<p>我们在 SimpleDrogonTest 文件夹下执行上述命令，即可在 SimpleDrogonTest 文件夹下生成一个名为 Demo 的工程，Demo 文件夹下生成相关的构建文件和文件夹。</p>
<p>文件夹的名字就反应了其用途，比如 controllers 代表控制器、filters 代表过滤器、plugins 代表插件，build 文件夹就是 cmake 构建输出目录。通过上述方式可以更好的实现项目管理。</p>
<p>我们看一下 main.cc 文件的内容，内容如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/drogon.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Set HTTP listener address and port</span></span><br><span class="line">    drogon::<span class="built_in">app</span>().<span class="built_in">addListener</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">5555</span>);</span><br><span class="line">    <span class="comment">//Load config file</span></span><br><span class="line">    <span class="comment">//drogon::app().loadConfigFile(&quot;../config.json&quot;);</span></span><br><span class="line">    <span class="comment">//drogon::app().loadConfigFile(&quot;../config.yaml&quot;);</span></span><br><span class="line">    <span class="comment">//Run HTTP framework,the method will block in the internal event loop</span></span><br><span class="line">    drogon::<span class="built_in">app</span>().<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="literal">-G</span> <span class="string">&quot;Ninja&quot;</span> <span class="literal">-DCMAKE_CXX_COMPILER</span>=clang<span class="literal">-cl</span> <span class="literal">-DCMAKE_TOOLCHAIN_FILE</span>=<span class="string">&quot;E:/ThirdPartyLibrary/vcpkg-2025.10.17/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;</span> ../</span><br></pre></td></tr></table></figure>

<p>或者是修改 CMakeLists.txt 文件，在 <code>project</code> 之前，添加下面代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="string">&quot;E:/ThirdPartyLibrary/vcpkg-2025.10.17/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;</span></span><br><span class="line">    CACHE <span class="keyword">STRING</span> <span class="string">&quot;Toolchain file for vcpkg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话，直接执行下述命令即可，执行完毕后，可执行程序在 build 文件夹下被成功生成</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake <span class="literal">-G</span> <span class="string">&quot;Ninja&quot;</span> <span class="literal">-DCMAKE_CXX_COMPILER</span>=clang<span class="literal">-cl</span> ../</span><br></pre></td></tr></table></figure>

<p>Http 根目录默认值是<code>&quot;./&quot;</code>， 也就是 webapp 程序运行的当前路径，即可执行程序所在的目录。依据该规则，我们可以在 build 文件夹下新建<code>index.html</code>文件，文件内容如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello From Drogon<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行 可执行程序，在浏览器输入 Web 地址<code>http://localhost:5555/</code> 或者<code>http://localhost:5555/index.html</code>，可以看到如下响应</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251030185520871.png" alt="image-20251030185520871"></p>
<p>上述是一个最简单的例子，一些细节等待后续介绍。</p>
<h3 id="四、控制器"><a href="#四、控制器" class="headerlink" title="四、控制器"></a>四、控制器</h3><h4 id="4-1-控制器的概念"><a href="#4-1-控制器的概念" class="headerlink" title="4.1 控制器的概念"></a>4.1 控制器的概念</h4><ul>
<li>在<code>Web</code>开发中，<strong>控制器（Controller）</strong> 是 <strong>MVC（Model-View-Controller）</strong> 设计模式中的一个核心组件。它的主要职责是<strong>接收用户的请求、处理请求（通常调用模型进行业务逻辑处理），并决定返回什么样的响应（通常是选择一个视图或直接返回数据）</strong>。</li>
<li><code>drogon</code>框架已经帮我们处理好网络传输、<code>Http</code>协议的解析等等细节，我们只需要关注控制器的逻辑即可；每一个控制器对象可以有一个或者多个处理函数(一般称为<code>handler</code>)，函数的接口，简单控制器对象只有一个处理接口，所有的请求都通过该接口进行处理。</li>
</ul>
<h4 id="4-2-控制器的创建"><a href="#4-2-控制器的创建" class="headerlink" title="4.2 控制器的创建"></a>4.2 控制器的创建</h4><p>通过<code>drogon_ctl</code>我们就可以创建控制器，上述介绍中我们通过 <code>drogon create project Demo</code>创建了一个名为<code>Demo</code>的项目，在其中有<code>controller</code>文件夹，切换到<code>controller</code>文件夹，执行 <code>drogon create controller FirstContoller</code>命令之后，<code>drogon_ctl</code>会为我们创建两个<code>FirstController.cc</code>和<code>FirstController.h</code> 文件，查看 <code>FirstController.h</code>文件，其内容如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpSimpleController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstController</span> : <span class="keyword">public</span> drogon::HttpSimpleController&lt;FirstController&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    PATH_LIST_BEGIN</span><br><span class="line">    <span class="comment">// list path definitions here;</span></span><br><span class="line">    <span class="comment">// PATH_ADD(&quot;/path&quot;, &quot;filter1&quot;, &quot;filter2&quot;, HttpMethod1, HttpMethod2...);</span></span><br><span class="line">    PATH_LIST_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>FirstController</code>继承了<code>drogon::HttpSimpleController&lt;FirstController&gt;</code>，<code>drogon::HttpSimpleController</code>称为简单控制器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span> <span class="keyword">override</span></span>; </span><br></pre></td></tr></table></figure>

<p>这个函数通过<code>override</code>关键字可以得知这是重写的父类的虚函数，<code>req</code>是<code>Http</code>请求的对象，由<code>std::shared_ptr</code>包裹。<code>callback</code>是框架传给控制器的回调函数对象，控制器生成应答对象(也通过智能指针包裹)后，通过<code>callback</code>把该对象传给<code>drogon</code>，然后框架会帮你把响应内容发送给浏览器。简单控制器的<code>Http</code>请求处理函数，其函数列表没有可以接收参数的位置，我们可以在函数体内部通过<code>req</code>去获取请求携带的参数。</p>
<h4 id="4-3-控制器的生命周期"><a href="#4-3-控制器的生命周期" class="headerlink" title="4.3 控制器的生命周期"></a>4.3 控制器的生命周期</h4><ul>
<li><p>注册到drogon框架的控制器最多只会有一个实例，在整个应用运行期间都不会销毁，所以，用户可以在控制器类中声明和使用成员变量。注意，控制器的handler被调用时，是在多线程环境下的（当框架的IO线程数配置成大于1的值时），如果需要访问非临时变量，请做好并发保护工作。</p>
</li>
<li><p>比如说我们使用控制器<code>HttpController</code>，可以注册多个<code>Http</code>请求处理函数<code>handler</code>，我们的框架的<code>IO</code>线程大于 1 的时候，每个线程都可能调用同一控制器的不同的<code>handler</code></p>
</li>
<li><table>
<thead>
<tr>
<th>时间</th>
<th align="left">IO线程1</th>
<th>IO线程2</th>
<th>IO线程3</th>
<th>IO线程4</th>
</tr>
</thead>
<tbody><tr>
<td>t1</td>
<td align="left">call<code>getUsers()</code></td>
<td>call<code>createUser()</code></td>
<td>空闲</td>
<td>空闲</td>
</tr>
<tr>
<td>t2</td>
<td align="left">空闲</td>
<td>call<code>getUserById()</code></td>
<td>call<code>updateUser()</code></td>
<td>空闲</td>
</tr>
</tbody></table>
<p>所有的这些调用都是在同一个控制器实例上进行的，如果我们在控制器中定义了一个成员变量，在不同的<code>handler</code>中对这个成员变量进行了修改，就会导致并发问题。</p>
<p>可以使用<code>std::mutex</code>、<code>std::atomic</code>等做好并发保护。</p>
</li>
</ul>
<h4 id="4-4-控制器的分类"><a href="#4-4-控制器的分类" class="headerlink" title="4.4 控制器的分类"></a>4.4 控制器的分类</h4><h5 id="4-3-1-HttpSimpleController"><a href="#4-3-1-HttpSimpleController" class="headerlink" title="4.3.1 HttpSimpleController"></a>4.3.1 HttpSimpleController</h5><ul>
<li><p>我们可以通过<code>drogon_ctl create controller [-s] &lt;[namespace::]class_name&gt;</code>命令去快速生成基于<code>HttpSimpleController</code>的自定义源文件。</p>
</li>
<li><p>其中<code>[-s]</code>表示该参数是可选的，<code>-s</code>表示生成继承<code>HttpSimpleController</code>的控制器类，<code>[namespace::]</code>表示命名空间，添加该参数，会在生成的控制器类外添加一个名称为<code>namespcae</code>的命名空间，可以将<code>namespcae</code>替换成你想要的名称。</p>
<p>我们通过<code>drogon_ctl create controller TimeCtrl</code>命令，创建一个名称为<code>TimeCtrl</code>的控制器。执行完命令后，在命令执行的目录下，可以看到新增的<code>TimeCtrl.h</code>和<code>TimeCtrl.cc</code>文件。下面查看一下这两个文件的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#TimeCtrl.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpSimpleController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeCtrl</span> : <span class="keyword">public</span> drogon::HttpSimpleController&lt;TimeCtrl&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    PATH_LIST_BEGIN</span><br><span class="line">    <span class="comment">// list path definitions here;</span></span><br><span class="line">    <span class="comment">// PATH_ADD(&quot;/path&quot;, &quot;filter1&quot;, &quot;filter2&quot;, HttpMethod1, HttpMethod2...);</span></span><br><span class="line">    PATH_LIST_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># TimeCtrl.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimeCtrl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimeCtrl::asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write your application logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个<code>HttpSimpleController</code>类只能定义一个<code>Http</code>请求处理函数，而且是通过重写父类虚函数定义的。</p>
</li>
<li><p>可以看到<code>TimeCtrl.h</code>中有三个宏<code>PATH_LIST_BEGIN</code>和<code>PATH_LIST_END</code>以及<code>PATH_ADD</code>。</p>
</li>
<li><p>从<code>URL</code>路径到处理函数的路由(或称映射)由宏完成，可以用<code>PATH_ADD</code>宏添加多重路径映射，所有<code>PATH_ADD</code>语句应夹在<code>PATH_LIST_BEGIN</code>和<code>PATH_LIST_END</code>宏语句之间。</p>
</li>
<li><p><code>PATH_ADD</code>宏第一个参数是映射的路径，路径后面的参数是对这个路径的约束，目前支持两种约束，一种是<code>HttpMethod</code>类型，表示该路径允许使用的<code>Http</code>方法，可以配置零个或多个，一种是<code>HttpFilter</code>类的名字，这种对象执行特定的过滤操作，也可以配置<code>0</code>个或多个，两种类型没有顺序要求，框架会处理好类型的匹配。<code>HttpFilter</code>称为过滤器，关于过滤器，等待后续介绍。</p>
</li>
<li><p>用户可以把同一个<code>Simple Controller</code>注册到多个路径上，也可以在同一个路径上注册多个<code>Simple Controller</code>通过<code>HTTP method</code>区分）。这句话的意思就是说。我们可以在一个<code>HttpSimpleController</code>中添加多个<code>PATH_ADD</code>宏，比如下面代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个HttpSimpleController 中注册多个URL</span></span><br><span class="line"><span class="built_in">PATH_ADD</span>(<span class="string">&quot;/time&quot;</span>, Get, Post);</span><br><span class="line"><span class="built_in">PATH_ADD</span>(<span class="string">&quot;/testmulti&quot;</span>, Get, Post);</span><br><span class="line"><span class="comment">// 表明上述路由都由该控制器进行处理，我们可以在处理函数中根据请求path进行不同的处理</span></span><br></pre></td></tr></table></figure>

<p>在同一个路径上注册多个<code>Simple Controller</code>是在不同的<code>HttpSimpleController</code>中添加相同的<code>URL</code>，具体是通过不同的<code>Http</code>请求方法进行处理，但是如果不小心添加了相同的URL和Http请求方法，比如<code>PATH_ADD(&quot;/test&quot;, Get, Post)</code>在多个<code>HttpSimpleController</code>中出现，这个时候就是调用后构造的控制器的处理函数，控制器实例化的顺序，目前猜测是按照控制器名称代表字符串的大小进行实例化，名称代表的字符串越大，实例化越晚。</p>
</li>
</ul>
<h5 id="4-3-2-HttpController"><a href="#4-3-2-HttpController" class="headerlink" title="4.3.2 HttpController"></a>4.3.2 HttpController</h5><ul>
<li><p>我们通过<code>drogon_ctl create controller -h hz::Test</code>命令，创建一个名称为<code>Test</code>的控制器。执行完命令后，在命令执行的目录下，可以看到新增的<code>hz_Test.h</code>和<code>hz_Test.cc</code>文件。下面查看一下这两个文件的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#hz_Test.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hz</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> drogon::HttpController&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    METHOD_LIST_BEGIN</span><br><span class="line">    <span class="comment">// use METHOD_ADD to add your custom processing function here;</span></span><br><span class="line">    <span class="comment">// METHOD_ADD(Test::get, &quot;/&#123;2&#125;/&#123;1&#125;&quot;, Get); // path is /hz/Test/&#123;arg2&#125;/&#123;arg1&#125;</span></span><br><span class="line">    <span class="comment">// METHOD_ADD(Test::your_method_name, &quot;/&#123;1&#125;/&#123;2&#125;/list&quot;, Get); // path is /hz/Test/&#123;arg1&#125;/&#123;arg2&#125;/list</span></span><br><span class="line">    <span class="comment">// ADD_METHOD_TO(Test::your_method_name, &quot;/absolute/path/&#123;1&#125;/&#123;2&#125;/list&quot;, Get); // path is /absolute/path/&#123;arg1&#125;/&#123;arg2&#125;/list</span></span><br><span class="line"></span><br><span class="line">    METHOD_LIST_END</span><br><span class="line">    <span class="comment">// your declaration of processing function maybe like this:</span></span><br><span class="line">    <span class="comment">// void get(const HttpRequestPtr&amp; req, std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback, int p1, std::string p2);</span></span><br><span class="line">    <span class="comment">// void your_method_name(const HttpRequestPtr&amp; req, std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback, double p1, int p2) const;</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#hz_Test.cc</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hz_Test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add definition of your processing function here</span></span><br></pre></td></tr></table></figure>

<p>我们编辑以下这两个文件，再进行阐述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hz_Test.h 修改如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> drogon::HttpController&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    METHOD_LIST_BEGIN</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加路径映射</span></span><br><span class="line">    <span class="built_in">METHOD_ADD</span>(Test::getInfo, <span class="string">&quot;/getInfo?name=&#123;1&#125;&amp;gender=&#123;2&#125;&quot;</span>, Get);</span><br><span class="line">    <span class="built_in">METHOD_ADD</span>(Test::test, <span class="string">&quot;/hzTest&quot;</span>, Get);</span><br><span class="line">    </span><br><span class="line">    METHOD_LIST_END</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//自定义Http请求处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getInfo</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback, std::string name, std::string gender)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hz_Test.cc 修改如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hz_Test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hz;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> hz::Test::<span class="built_in">getInfo</span>(<span class="type">const</span> HttpRequestPtr &amp;req, std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback, std::string name, std::string gender)</span><br><span class="line">&#123;</span><br><span class="line">    Json::Value value;</span><br><span class="line">    value[<span class="string">&quot;name&quot;</span>] = name;</span><br><span class="line">    value[<span class="string">&quot;gender&quot;</span>] = gender;</span><br><span class="line">    value[<span class="string">&quot;age&quot;</span>] = <span class="number">23</span>;</span><br><span class="line">    value[<span class="string">&quot;school&quot;</span>] = <span class="string">&quot;AYNU&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> response = drogon::HttpResponse::<span class="built_in">newHttpJsonResponse</span>(value);</span><br><span class="line">    <span class="built_in">callback</span>(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> hz::Test::<span class="built_in">test</span>(<span class="type">const</span> HttpRequestPtr &amp;req, std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span><br><span class="line">&#123;</span><br><span class="line">    Json::Value value;</span><br><span class="line">    value[<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;test function&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> response = drogon::HttpResponse::<span class="built_in">newHttpJsonResponse</span>(value);</span><br><span class="line">    <span class="built_in">callback</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>HttpController</code>类可以定义多个<code>Http</code>请求处理函数<code>handler</code>，由于函数数目可以任意多，所以通过虚函数重载是不现实的，我们需要把<code>handler</code>本身(而不是类)注册到框架里去。</p>
</li>
<li><p>从<code>URL</code>路径到处理函数的映射由宏完成，可以用<code>METHOD_ADD</code>宏或<code>ADD_METHOD_TO</code>宏添加多重路径映射，所有<code>METHOD_ADD</code>和<code>ADD_METHOD_TO</code>语句应夹在<code>METHOD_LIST_BEGIN</code>和<code>METHOD_LIST_END</code>宏语句之间。</p>
</li>
<li><p><code>METHOD_ADD</code>宏会在路径映射中自动把<strong>命名空间和类名</strong>作为路径的前缀，所以，本例子中，<code>getInfo</code>函数，被注册到了<code>/hz/test/getinfo</code>路径上，<code>test</code>函数被注册到了<code>/hz/test/hzTest</code>路径上。后面的约束跟<code>HttpSimpleController</code>的<code>PATH_ADD</code>宏类似，不再赘述。</p>
</li>
<li><p>如果使用了自动的前缀，访问地址要包含命名空间和类名，此例中要使用<code>http://localhost:8888/hz/test/getinfo?name=xxx&amp;gender=xxx</code>或者<code>http://localhost:8888/hz/test/hztest</code>来访问。</p>
</li>
<li><p><code>ADD_METHOD_TO</code>宏的作用与前者几乎一样，除了它不会自动添加任何前缀，即这个宏注册的路径是一个绝对路径。</p>
</li>
<li><p>通过上述例子我们可以看到<code>HttpController</code>提供了更为灵活的路径映射功能，并且可以注册多个处理函数，我们可以将一类功能放在一个类里。</p>
</li>
<li><p>另外可以看到，<code>METHOD_ADD</code>宏提供了参数映射的方法，我们可以把路径上的参数映射到函数的参数表里，由参数的数码对应形参的位置，非常方便，常见的可以由字符串类型转换的类型都可以作为参数(如<code>std::string,int,float,double</code>等等)，框架基于模板的类型推断会自动帮你转换类型，非常方便。如果路径参数和函数参数不匹配或者是不能进行转换，框架会报错。注意左值引用必须是<code>const</code>类型，这点要求是因为框架传递过来的数据是临时值，如果使用非常量左值引用，代表我们可以修改这个临时值，这会引发未定义行为，是不允许的，编译不会通过。</p>
</li>
<li><p>同一个路径还可以注册多次，相互之间通过<code>Http Method</code>区分，这是合法的，并且是Restful API的通常做法，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">METHOD_LIST_BEGIN</span></span><br><span class="line"><span class="function">    <span class="title">METHOD_ADD</span><span class="params">(Test::deleteBook, <span class="string">&quot;/&#123;1&#125;&quot;</span>, Delete)</span></span>;</span><br><span class="line">    <span class="built_in">METHOD_ADD</span>(Test::addBook, <span class="string">&quot;/&#123;1&#125;&quot;</span>, Post);</span><br><span class="line">  METHOD_LIST_END</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteBook</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback, std::string bookId)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addBook</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback, std::string bookId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>路径参数的占位符有多种写法:</p>
<ul>
<li>{}: 表示这个路径参数映射到处理函数的对应位置上，路径上的位置就是函数参数的位置。</li>
<li>{1}，{2}: 中间有个数字的，表示映射到数字指定的处理函数参数上。</li>
<li>{anystring}: 中间的字符串没有实际作用，但可以提高程序的可读性，与<code>&#123;&#125;</code>等价。</li>
<li>{1:anystring},{2:xxx}: 冒号前的数字表示位置，后面的字符串没有实际作用，但可以提高程序的可读性，与<code>&#123;1&#125;</code>,<code>&#123;2&#125;</code>等价。</li>
</ul>
</li>
<li><p>路径匹配大小写不敏感，参数名字大小写敏感，参数值大小写保持原貌，就是说我们的<code>URL</code>大小写不敏感，但是其传递的参数大小写敏感，我们在请求处理函数中，通过<code>http</code>请求对象去获取参数数据的时候，注意保持大小写一致。</p>
</li>
<li><p>通过前面的叙述我们知道，路径上的参数和问号后面的请求参数都可以映射到处理函数的参数列表里，目标参数的类型需要满足如下条件：</p>
<ul>
<li>必须是值类型、常左值引用或非<code>const</code>右值引用中的一种，不能是<strong>非const的左值引用</strong>，推荐使用右值引用，这样用户可以随意处置它；</li>
<li><code>int, long, long long, unsigned long, unsigned long long, float, double, long double, std::string</code>等基础类型都可以作为参数类型；</li>
<li>任何可以使用<code>stringstream &gt;&gt;</code>操作符赋值的类型；</li>
</ul>
</li>
</ul>
<h5 id="4-3-3-WebSocketController"><a href="#4-3-3-WebSocketController" class="headerlink" title="4.3.3 WebSocketController"></a>4.3.3 WebSocketController</h5><ul>
<li><p>顾名思义，<code>WebSocketController</code>用于处理<code>websocket</code>逻辑。<code>websocket</code>是基于<code>Http</code>的一种长连接方案，在<code>websocket</code>建立之初，有一次<code>Http</code>格式的请求和应答交换，建立完成后，所有的消息在<code>websocket</code>上传输，消息由固定的格式包装，但消息的内容和收发次序没有任何要求，完全由用户定义。</p>
</li>
<li><p>我们通过<code>drogon_ctl create controller -w EchoWebSocket</code>命令去创建基于<code>WebSocketController</code>的自定义源文件。执行完命令后，在命令执行的目录下可以看到<code>EchoWebSocket.h</code>和<code>EchoWebSocket.cc</code>文件被创建，下面查看以下这两个源文件的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#EchoWebSocket.h </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/WebSocketController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoWebSocket</span> : <span class="keyword">public</span> drogon::WebSocketController&lt;EchoWebSocket&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">handleNewMessage</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string &amp;&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> WebSocketMessageType &amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleNewConnection</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> WebSocketConnectionPtr&amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleConnectionClosed</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    WS_PATH_LIST_BEGIN</span><br><span class="line">    <span class="comment">// list path definitions here;</span></span><br><span class="line">    <span class="comment">// WS_PATH_ADD(&quot;/path&quot;, &quot;filter1&quot;, &quot;filter2&quot;, ...);</span></span><br><span class="line">    WS_PATH_LIST_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#EchoWebSocket.cc</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EchoWebSocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleNewMessage</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr, std::string &amp;&amp;message, <span class="type">const</span> WebSocketMessageType &amp;type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// wsConnPtr-&gt;send(&quot;resend message&quot; + message);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleNewConnection</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req, <span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write your application logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleConnectionClosed</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write your application logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们简单编辑以下文件的内容并进行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改EchoWebSocket.h以下部分</span></span><br><span class="line"><span class="function">WS_PATH_LIST_BEGIN</span></span><br><span class="line"><span class="function"><span class="title">WS_PATH_ADD</span><span class="params">(<span class="string">&quot;/echo&quot;</span>)</span></span>;</span><br><span class="line">WS_PATH_LIST_END</span><br><span class="line">    </span><br><span class="line"><span class="comment">//修改 EchoWebSocket.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EchoWebSocket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleNewMessage</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr, std::string &amp;&amp;message, <span class="type">const</span> WebSocketMessageType &amp;type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;received messages: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> localTime = std::chrono::<span class="built_in">current_zone</span>()-&gt;<span class="built_in">to_local</span>(now);</span><br><span class="line">    std::string responseStr = std::format(<span class="string">&quot;Your local time is &#123;:%Y-%m-%d %H:%M:%S&#125;&quot;</span>, localTime);</span><br><span class="line">    <span class="comment">//发送消息给对端</span></span><br><span class="line">    wsConnPtr-&gt;<span class="built_in">send</span>(responseStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleNewConnection</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req, <span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收到新连接后，打印自己和对端的IP地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;local address is: &quot;</span> &lt;&lt; wsConnPtr-&gt;<span class="built_in">localAddr</span>().<span class="built_in">toIp</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;peer address is: &quot;</span> &lt;&lt; wsConnPtr-&gt;<span class="built_in">peerAddr</span>().<span class="built_in">toIp</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EchoWebSocket::handleConnectionClosed</span><span class="params">(<span class="type">const</span> WebSocketConnectionPtr&amp; wsConnPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理连接断开</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connection is closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>首先，在这个例子中，通过<code>WS_PATH_ADD</code>宏把这个控制器注册到了<code>/echo</code>路径上，<code>WS_PATH_ADD</code>宏的用法跟之前介绍的其他控制器的宏类似，也可以注册路径并且附带若干中间件和过滤器。由于<code>websocket</code>在框架中单独处理，所以它可以和前两种控制器的路径重复而不会相互影响。</p>
</li>
<li><p>本例中通过<code>drogon_ctl</code>创建的<code>WebSocketController</code>生成的三个函数分别是处理新消息、处理新连接、处理连接断开，这里只是做了简单的打印，来验证函数是否被调用。</p>
</li>
<li><p><code>handleNewConnection</code>在<code>websocket</code>建立之后被调用，<code>req</code>是客户端发来的建立请求，这时候框架已经返回了<code>response</code>，用户可以做的是通过<code>req</code>获得一些额外信息，比如<code>token</code>之类。<code>wsConn</code>是这个<code>websocket</code>对象的智能指针，常用的接口等待后续介绍。</p>
</li>
<li><p><code>handleNewMessage</code>在<code>websocket</code>收到新的消息之后被调用，消息存储在<code>message</code>变量里，注意这个<code>message</code>是<strong>完整的消息净荷</strong>，框架已经做完了消息的解封包和解码等工作，用户直接处理消息本身即可。</p>
</li>
<li><p><code>handleConnectionClosed</code>在<code>websocket</code>连接关闭之后调用，用户可以做一些收尾工作。</p>
</li>
<li><p>使用<code>Postman</code>工具进行测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031151019148.png" alt="image-20251031151019148"></p>
</li>
</ul>
<p>点击<code>Connect</code>之后，在服务端可以看到<code>handleNewConnection</code>函数被调用，打印了本机和对端的IP地址。</p>
<p>点击 <code>send</code>之后，可以看到输入框的消息<code>Hello</code>被成功发送。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031151502467.png" alt="image-20251031151502467"></p>
<p>WebSocket保活机制，心跳检测，稍后写。</p>
<h3 id="五、中间件和过滤器"><a href="#五、中间件和过滤器" class="headerlink" title="五、中间件和过滤器"></a>五、中间件和过滤器</h3><h4 id="5-1-中间件和过滤器的概念"><a href="#5-1-中间件和过滤器的概念" class="headerlink" title="5.1 中间件和过滤器的概念"></a>5.1 中间件和过滤器的概念</h4><ul>
<li>中间件(<code>middleware</code>)和过滤器(<code>filter</code>)可以帮助用户提高编程效率，在<code>HttpController</code>的例子中，<code>getInfo</code>方法我们是作为获取用户信息使用的，所以在返回用户信息之前应该先校验用户是否登录，避免非法用户获取信息，我们把这个逻辑写在getInfo方法里当然是可以的。但是，很显然，校验用户登录属于通用逻辑，很多接口都将用到，应该把它单独提取出来，再配置到调用<code>handler</code>之前，这就是<code>filter</code>的作用。</li>
<li><code>drogon</code>的中间件采用了<strong>洋葱圈模型</strong>，框架做完<code>URL</code>路径匹配后，会依次调用注册到该路径上的中间件，在每个中间件中，用户可以选择拦截或放行请求，并添加前置、后置处理逻辑。 如果有一个中间件拦截了请求，该请求将不会继续深入洋葱圈内层，对应的<code>handler</code>也不会被调用，但是仍然会通过外层中间件的后置处理逻辑。</li>
<li>过滤器实际上是省略后置操作的中间件，经过进一步的包装后暴露给用户。中间件和过滤器可以在注册路径时混合使用。</li>
<li>注意: 如果中间件&#x2F;过滤器定义在命名空间里，注册时必须把命名空间写全。</li>
</ul>
<h4 id="5-2-内置中间件和过滤器"><a href="#5-2-内置中间件和过滤器" class="headerlink" title="5.2 内置中间件和过滤器"></a>5.2 内置中间件和过滤器</h4><p><code>drogon</code>中内置了以下常用的过滤器</p>
<ul>
<li><code>drogon::IntranetIpFilter</code>:只放行内网ip发来的http请求，否则返回404页面；</li>
<li><code>drogon::LocalHostFilter</code>:只放行本机127.0.0.1或者::1发来的http请求，否则返回404页面；</li>
</ul>
<p>上述两种内置的过滤器也是以字符串的形式给定的，比如<code>PATH_ADD(&quot;/time&quot;,&quot;drogon::LocalHostFilter&quot;, Get, Post);</code>这种写法，名称不对或过滤器不存在，框架会报<code>ERROR middleware LocalHostFilter not found</code>的错误。</p>
<h4 id="5-3-自定义中间件和过滤器"><a href="#5-3-自定义中间件和过滤器" class="headerlink" title="5.3 自定义中间件和过滤器"></a>5.3 自定义中间件和过滤器</h4><h5 id="5-3-1-中间件的定义"><a href="#5-3-1-中间件的定义" class="headerlink" title="5.3.1 中间件的定义"></a>5.3.1 中间件的定义</h5><p>用户可以自定义中间件，需要继承<code>HttpMiddleware</code>类模板，模板类型就是子类类型，比如我们自定义中间件如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyMiddleware.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpMiddleware.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMiddleware</span> : <span class="keyword">public</span> drogon::HttpMiddleware&lt;MyMiddleware&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyMiddleware</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">invoke</span><span class="params">(<span class="type">const</span> drogon::HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                        drogon::MiddlewareNextCallback &amp;&amp;nextCb,</span></span></span><br><span class="line"><span class="params"><span class="function">                        drogon::MiddlewareCallback &amp;&amp;mcb)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyMiddleware.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyMiddleware.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyMiddleware::<span class="built_in">MyMiddleware</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//记得中间件要写构造函数，默认即可</span></span><br><span class="line">    <span class="comment">//如果忘记定义构造函数，则在注册路径时会出现找不到中间件的错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMiddleware::invoke</span><span class="params">(<span class="type">const</span> drogon::HttpRequestPtr &amp;req, drogon::MiddlewareNextCallback &amp;&amp;nextCb, drogon::MiddlewareCallback &amp;&amp;mcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string origin = req-&gt;<span class="built_in">getHeader</span>(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">find</span>(<span class="string">&quot;www.example.com&quot;</span>) != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;origin is invalid domain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// intercept directly</span></span><br><span class="line">        <span class="built_in">mcb</span>(drogon::HttpResponse::<span class="built_in">newNotFoundResponse</span>(req));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do something before calling the next middleware</span></span><br><span class="line">    <span class="built_in">nextCb</span>([mcb = std::<span class="built_in">move</span>(mcb), origin = std::<span class="built_in">move</span>(origin)](<span class="type">const</span> drogon::HttpResponsePtr &amp;resp) &#123;</span><br><span class="line">        <span class="comment">// Do something after the next middleware returns</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;MyMiddleware nextCb&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="built_in">mcb</span>(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到自定义的中间件<code>MyMiddleware</code>类继承<code>HttpMiddleware</code>类并重写父类虚函数<code>invoke</code>，该函数有三个参数，分别是</p>
<ul>
<li><code>const drogon::HttpRequestPtr &amp;req</code>,    表示<code>Http</code>请求                    </li>
<li><code>drogon::MiddlewareNextCallback &amp;&amp;nextCb</code>,   进入内层的回调函数，调用该函数意味着继续深入洋葱圈内层，调用下一个中间件或最终<code>handler</code>。 调用<code>nextCb</code>时接受另一个函数作为参数, 当从洋葱圈内层返回时，该函数会被调用，并传入内层返回的<code>HttpResponsePtr</code>。</li>
<li><code>drogon::MiddlewareCallback &amp;&amp;mcb</code>，返回上层的回调函数，调用该函数意味着返回洋葱圈上层。若跳过<code>nextCb</code>只调用<code>mcb</code>，意味着拦截该请求，直接返回上层。</li>
</ul>
<h5 id="5-3-2-过滤器的定义"><a href="#5-3-2-过滤器的定义" class="headerlink" title="5.3.2 过滤器的定义"></a>5.3.2 过滤器的定义</h5><p>用户可以自定义过滤器，需要继承<code>HttpFilter</code>类模板，模板类型就是子类类型，比如我们想做一个<code>LoginFilter</code>，就可以定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LoginFilter.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpFilter.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginFilter</span> : <span class="keyword">public</span> HttpFilter&lt;LoginFilter&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoginFilter</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doFilter</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                  FilterCallback &amp;&amp;fcb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  FilterChainCallback &amp;&amp;fccb)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LoginFilter.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LoginFilter.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoginFilter::doFilter</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FilterCallback &amp;&amp;fcb,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FilterChainCallback &amp;&amp;fccb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Edit your logic here</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Passed</span></span><br><span class="line">        <span class="built_in">fccb</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Check failed</span></span><br><span class="line">    <span class="keyword">auto</span> res = drogon::HttpResponse::<span class="built_in">newHttpResponse</span>();</span><br><span class="line">    res-&gt;<span class="built_in">setStatusCode</span>(k500InternalServerError);</span><br><span class="line">    <span class="built_in">fcb</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过滤器是我们通过执行<code>drogon_ctl create filter LoginFilter</code>命令创建来的，可以看到<code>LoginFilter</code>继承<code>HttpFilter&lt;LoginFilter&gt;</code>，并且重写了父类的虚函数<code>doFilter</code>，该虚函数有三个参数，分别是：</p>
<ul>
<li><code>const HttpRequestPtr &amp;req</code>，<code>http</code>请求。</li>
<li><code>FilterCallback &amp;&amp;fcb</code>，过滤器回调函数，当过滤器判定请求不合法时，通过这个回调把特定的响应返回给浏览器。</li>
<li><code>FilterChainCallback &amp;&amp;fccb</code>：过滤器链回调函数，当过滤器判定请求合法时，通过这个回调告诉<code>drogon</code>调用下一个过滤器或者最终的<code>handler</code>。</li>
</ul>
<h4 id="5-4-中间件单独测试"><a href="#5-4-中间件单独测试" class="headerlink" title="5.4 中间件单独测试"></a>5.4 中间件单独测试</h4><p>我们定义一个名为<code>MyMiddleware</code>的中间件，以下是其对应的文件内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#MyMiddleware.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpMiddleware.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMiddleware</span> : <span class="keyword">public</span> drogon::HttpMiddleware&lt;MyMiddleware&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyMiddleware</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">invoke</span><span class="params">(<span class="type">const</span> drogon::HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                        drogon::MiddlewareNextCallback &amp;&amp;nextCb,</span></span></span><br><span class="line"><span class="params"><span class="function">                        drogon::MiddlewareCallback &amp;&amp;mcb)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyMiddle.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyMiddleware.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMiddleware::invoke</span><span class="params">(<span class="type">const</span> drogon::HttpRequestPtr &amp;req, drogon::MiddlewareNextCallback &amp;&amp;nextCb, drogon::MiddlewareCallback &amp;&amp;mcb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是跨域请求</span></span><br><span class="line">    std::string origin = req-&gt;<span class="built_in">getHeader</span>(<span class="string">&quot;Origin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (origin.<span class="built_in">find</span>(<span class="string">&quot;www.example.com&quot;</span>) != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;invalid request&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;origin is invalid domain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">mcb</span>(drogon::HttpResponse::<span class="built_in">newNotFoundResponse</span>(req));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">nextCb</span>([mcb = std::<span class="built_in">move</span>(mcb), origin = std::<span class="built_in">move</span>(origin)](<span class="type">const</span> drogon::HttpResponsePtr &amp;resp) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;enter nextcb&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;response body is: &quot;</span> &lt;&lt; resp-&gt;<span class="built_in">body</span>() &lt;&lt; std::endl;</span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin);</span><br><span class="line">        resp-&gt;<span class="built_in">addHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="built_in">mcb</span>(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再定义一个简单的控制器<code>TimeController</code>，以下是其对应的文件内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TimeController.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpSimpleController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimtController</span> : <span class="keyword">public</span> drogon::HttpSimpleController&lt;TimtController&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    PATH_LIST_BEGIN</span><br><span class="line">    <span class="comment">// 我们在这里注册路径，并添加中间件</span></span><br><span class="line">    <span class="built_in">PATH_ADD</span>(<span class="string">&quot;/time&quot;</span>, <span class="string">&quot;MyMiddleware&quot;</span>, Get, Post);</span><br><span class="line">    PATH_LIST_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TimeController.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TimtController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimtController::asyncHandleHttpRequest</span><span class="params">(<span class="type">const</span> HttpRequestPtr&amp; req, std::function&lt;<span class="type">void</span> (<span class="type">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resp=HttpResponse::<span class="built_in">newHttpResponse</span>();</span><br><span class="line">    resp-&gt;<span class="built_in">setStatusCode</span>(k200OK);</span><br><span class="line">    resp-&gt;<span class="built_in">setContentTypeCode</span>(CT_TEXT_HTML);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> localTime = std::chrono::<span class="built_in">current_zone</span>()-&gt;<span class="built_in">to_local</span>(now);</span><br><span class="line">    std::string responseStr = std::format(<span class="string">&quot;Your local time is &#123;:%Y-%m-%d %H:%M:%S&#125;&quot;</span>, localTime);</span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(responseStr);</span><br><span class="line">    <span class="built_in">callback</span>(resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们在控制器注册路径，并添加了<code>MyMiddleware</code>中间件，这样的话，框架在做完<code>URL</code>匹配以后，会依次调用注册在该路径上的中间件。</p>
<p>使用<code>Postman</code>进行测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031163159354.png" alt="image-20251031163159354"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031163303505.png" alt="image-20251031163303505"></p>
<p>可以看到我们没有在请求头中添加<code>Origin</code>字段，服务端响应如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031163456663.png" alt="image-20251031163456663"></p>
<p>可以看到服务端调用了<code>nextCb</code>函数，并触发了其回调函数，<code>nextCb</code>函数注册的回调函数中<code>const drogon::HttpResponsePtr &amp;resp</code>参数由控制器<code>TimtController</code>的<code>asyncHandleHttpRequest</code>中调用<code>callback</code>函数返回而来。</p>
<p><code>nextCb</code>回调函数调用<code>mcb</code>函数，将响应返回给客户端。</p>
<p>在<code>Http</code>请求头中添加<code>Oringin</code>字段和其对应的值<code>www.example.com</code>，可以看到服务端返回了<code>404</code>的响应，这是因为中间件<code>MyMiddleware</code>直接调用了<code>mcb</code>函数，返回响应给客户端。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031164504934.png" alt="image-20251031164504934"></p>
<h4 id="5-5-过滤器单独测试"><a href="#5-5-过滤器单独测试" class="headerlink" title="5.5 过滤器单独测试"></a>5.5 过滤器单独测试</h4><p>我们定义一个名为<code>MyFilter</code>的过滤器，以下是其对应的文件内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#MyFilter.h</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drogon/HttpFilter.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFilter</span> : <span class="keyword">public</span> HttpFilter&lt;MyFilter&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyFilter</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doFilter</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                  FilterCallback &amp;&amp;fcb,</span></span></span><br><span class="line"><span class="params"><span class="function">                  FilterChainCallback &amp;&amp;fccb)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#MyFilter.cc</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFilter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> drogon;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFilter::doFilter</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FilterCallback &amp;&amp;fcb,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FilterChainCallback &amp;&amp;fccb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> origin = req-&gt;<span class="built_in">getHeader</span>(<span class="string">&quot;Origin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(origin.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fccb</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Check failed</span></span><br><span class="line">    <span class="keyword">auto</span> res = drogon::HttpResponse::<span class="built_in">newHttpResponse</span>();</span><br><span class="line">    res-&gt;<span class="built_in">setStatusCode</span>(k500InternalServerError);</span><br><span class="line">    <span class="built_in">fcb</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依旧使用上述中间件单独测试中的控制器<code>TimeController</code>，修改其路径注册为<code>PATH_ADD(&quot;/time&quot;, &quot;MyFilter&quot;, Get, Post);</code></p>
<p>使用<code>Postman</code>进行测试，可以看到我们在请求头中没有添加<code>Origin</code>字段 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031170454573.png" alt="image-20251031170454573"></p>
<p>服务端在请求头中没有添加<code>Origin</code>的字段，服务端直接调用<code>fccb</code>函数，会调用最终的<code>handler</code>，也就是控制器的<code>http</code>请求处理函数，由控制器发送响应给客户端。</p>
<p>我们在<code>Http</code>请求头添加<code>Origin</code>字段和对应的值，可以看到服务端返回了<code>500</code>的状态码，也就是调用了<code>fcb</code>函数，通过该回调函数将响应发送给客户端。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251031171139148.png" alt="image-20251031171139148"></p>
<h4 id="5-6-中间件和过滤器混合使用"><a href="#5-6-中间件和过滤器混合使用" class="headerlink" title="5.6 中间件和过滤器混合使用"></a>5.6 中间件和过滤器混合使用</h4><h4 id="5-7-中间件和过滤器的区别"><a href="#5-7-中间件和过滤器的区别" class="headerlink" title="5.7 中间件和过滤器的区别"></a>5.7 中间件和过滤器的区别</h4><ul>
<li><code>drogon</code>文档中介绍<strong>过滤器实际上是省略后置操作的中间件</strong></li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMiddleware::invoke</span><span class="params">(<span class="type">const</span> drogon::HttpRequestPtr &amp;req, drogon::MiddlewareNextCallback &amp;&amp;nextCb, drogon::MiddlewareCallback &amp;&amp;mcb)</span></span></span><br><span class="line"><span class="function">      </span></span><br><span class="line"><span class="function"><span class="comment">// 过滤器</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doFilter</span><span class="params">(<span class="type">const</span> HttpRequestPtr &amp;req, FilterCallback &amp;&amp;fcb, FilterChainCallback &amp;&amp;fccb)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 注意到当使用中间件<code>MyMiddleware</code>的时候，我们在<code>nextCb</code>函数中对<strong>控制器返回的响应</strong>进行了进一步的修改，添加了<code>Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials</code>两个字段，表现了中间件的一种后置操作。</p>
<p>而过滤器就没有这种功能，过滤器的<code>fcb</code>函数在判定请求不合法时，直接返回响应给客户端，而且无法通过回调函数获取控制器返回的响应，没有后置操作。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>中间件（Middleware）</th>
<th>过滤器（Filter）</th>
</tr>
</thead>
<tbody><tr>
<td>是否支持前置检查</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
<tr>
<td>是否支持后置操作</td>
<td>✅ 是（通过 <code>nextCb</code> 回调）</td>
<td>❌ 否</td>
</tr>
<tr>
<td>能否修改响应</td>
<td>✅ 能（在 <code>nextCb</code> 回调中）</td>
<td>❌ 不能</td>
</tr>
<tr>
<td>能否添加动态响应头（如 CORS）</td>
<td>✅ 能（基于原始 <code>Origin</code>）</td>
<td>❌ 不能（除非控制器配合）</td>
</tr>
<tr>
<td>执行时机</td>
<td>路由匹配后，控制器执行前后</td>
<td>路由匹配后，控制器执行前</td>
</tr>
</tbody></table>
<h3 id="六、视图"><a href="#六、视图" class="headerlink" title="六、视图"></a>六、视图</h3><h4 id="6-1-视图的概念"><a href="#6-1-视图的概念" class="headerlink" title="6.1 视图的概念"></a>6.1 视图的概念</h4><ul>
<li><p>虽然目前前端渲染技术大行其道，使后端应用服务只需要返回相应数据给前端即可，不过，一个好的<code>web</code>框架还是应该提供后端渲染技术，使服务端程序可以动态生成<code>HTML</code>页面。视图可以帮助使用者生成这些页面，顾名思义，它只负责做跟展示相关的工作，而复杂的业务逻辑都应该交给控制器完成。</p>
</li>
<li><p>最早的<code>web</code>应用程序都是把<code>HTML</code>嵌入到程序编码里，达到动态生成<code>HTML</code>页面的目的，不过这样做有效率低、不直观等诸多缺点，于是出现了诸如<code>JSP</code>等语言，反其道而行之，把程序代码嵌入到HTML页面里。<code>drogon</code>采用的当然是后一种方案，不过，很明显，由于<code>C++</code>是编译执行的，我们需要把这种嵌入了<code>C++</code>代码的页面转换成<code>C++</code>源程序，才能编译进应用程序。所以，<code>drogon</code>定义了自己专门的<code>CSP(C++ Server Pages)</code>描述语言，使用命令行工具<code>drogon_ctl</code>可以把csp文件转换成<code>C++</code>源文件以供编译。</p>
</li>
</ul>
<h4 id="6-2-drogon-的-csp-的规则"><a href="#6-2-drogon-的-csp-的规则" class="headerlink" title="6.2 drogon 的 csp 的规则"></a>6.2 drogon 的 csp 的规则</h4><p><code>drogon</code>的<code>csp</code>方案很简单，我们用特殊的标记符号把<code>C++</code>代码嵌入到<code>HTML</code>页面里就可以了。</p>
<ul>
<li>夹在标签<code>&lt;%inc</code>和<code>%&gt;</code>之间的内容被视为需要引用的头文件部分，这里只能写入<code>#include</code>语句，如<code>&lt;%inc#include &quot;xx.h&quot; %&gt;</code>,不过很多常见的头文件<code>drogon</code>都自动包含了，用户基本上用不到这个标签。</li>
<li>夹在标签<code>&lt;%c++</code>和<code>%&gt;</code>之间的所有内容都被视为<code>C++</code>的代码,如<code>&lt;c++ std:string name=&quot;drogon&quot;; %&gt;</code>。</li>
<li><code>C++</code>的代码一般都会原封不动的转移到目标源文件中，除了下面两种特殊标记：<ul>
<li><code>@@</code>代表控制器传过来的<code>data</code>变量，类型是<code>HttpViewData</code>，可以从中获取需要的内容；</li>
<li><code>$$</code>代表表示页面内容的流对象，可以把需要显示的内容通过<code>&lt;&lt;</code>操作符显示在页面上；</li>
</ul>
</li>
<li>夹在标签<code>[[</code>和<code>]]</code>之间的内容被认为是变量名字，<code>view</code>会以这个名字为<code>keyword</code>从控制器传过来的数据里找到对应的变量，并把它输出到页面的对应位置，变量名字前后的空格会被省略，<code>[[</code>和<code>]]</code>不要分行写，同时，出于性能考虑，只支持三种字符串数据类型<code>(const char *,std::string和const std::string</code>，因为输出时涉及数据类型判断，过多类型会导致过多的条件语句)，其他数据类型请用上面提到的方式输出(或者将需要输出的变量以<code>string</code>类型存入<code>data</code>中)。</li>
<li>夹在标签<code>&#123;%`和`%&#125;</code>之间的内容被认为是<code>C++</code>程序里变量的名字或表达式（而不是控制器传过来的数据的<code>keyword</code>），view会把该变量的内容或表达式的值输出到页面的对应位置。容易知道<code>&#123;%val.xx%&#125;</code>等效于<code>&lt;%c++$$&lt;&lt;val.xx;%&gt;</code>，只是前者更为简单直观。同样的，两个标签不要分行写。</li>
<li>夹在标签<code>&lt;%view</code>和<code>%&gt;</code>之间的内容被认为是子视图的名字，框架会找到相应的子视图并把它的内容填充到该标签所在位置；视图名字前后的空格会被忽略，同时<code>&lt;%view</code>和<code>%&gt;</code>不要分行写，子视图和父视图共用控制器的数据, 可以多级嵌套但不要循环嵌套。</li>
<li>夹在标签<code>&lt;%layout</code>和<code>%&gt;</code>之间的内容被认为是布局的名字，框架会找到相应的布局并把本视图的内容填充到该布局的某个位置（在布局中由占位符<code>[[]]</code>标定该位置）；布局名字前后的空格会被忽略，同时<code>&lt;%layout</code>和<code>%&gt;</code>不要分行写，可以多级嵌套但不要循环嵌套。</li>
</ul>
<h4 id="6-3-视图的使用"><a href="#6-3-视图的使用" class="headerlink" title="6.3 视图的使用"></a>6.3 视图的使用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a response that returns a page rendered by a view named</span></span><br><span class="line">    <span class="comment">/// viewName.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param viewName The name of the view</span></span><br><span class="line"><span class="comment">     * @param data is the data displayed on the page.</span></span><br><span class="line"><span class="comment">     * @note For more details, see the wiki pages, the &quot;View&quot; section.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">static</span> HttpResponsePtr <span class="title">newHttpViewResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string &amp;viewName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> HttpViewData &amp;data = HttpViewData(),</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> HttpRequestPtr &amp;req = HttpRequestPtr())</span></span>;</span><br></pre></td></tr></table></figure>

<p>这是<code>newHttpViewResponse</code>的函数原型，通过注释可以看到参数<code>viewName</code>指代<code>.csp</code>文件的名称，<code>data</code>是展现在<code>html页面</code>中的数据，该参数有默认参数。</p>
<p>可以看到，控制器不需要引入视图的头文件，二者通过<code>data</code>变量进行关联，控制器和视图之间实现了很好的解耦。</p>
<p>由<code>drogon_ctl create project &lt;project_name&gt;</code>命令生成的项目中，会默认生成一个文件夹<code>views</code>，我们在<code>views</code>文件夹下新建文件<code>ListParameters.csp</code>，重新执行<code>cmake</code>，执行<code>make</code>或者<code>ninja</code>，这取决于你使用的是什么构建工具，执行该命令的时候，可以看到控制台的输出，例如：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>/<span class="number">3</span>] Generating ListParameters.h, ListParameters.cc</span><br><span class="line">create view:views/ListParameters.csp</span><br><span class="line">create HttpView <span class="class"><span class="keyword">Class</span> <span class="title">file</span> <span class="title">by</span> <span class="title">views</span>/<span class="title">ListParameters</span>.<span class="title">csp</span></span></span><br><span class="line"><span class="class"><span class="title">className</span>=<span class="title">ListParameters</span></span></span><br></pre></td></tr></table></figure>

<p>框架根据<code>views</code>文件夹下的<code>.csp</code>文件，生成同名的<code>.h</code>和<code>.cc</code>文件，这一过程是由框架自动完成的，具体可以看一下生成的<code>CMakeLists.txt</code>，其中包含如下命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drogon_create_views(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/views</span><br><span class="line">                    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><code>$&#123;PROJECT_NAME&#125;</code>是<code>CMake</code>项目的名称。<code>drogon_create_views</code> 需要知道这个名称，以便将生成的源文件正确地关联到你的可执行文件或库的构建目标中。它会将生成的 <code>.cc</code> 文件添加到这个目标的源文件列表里。</p>
<p><code>CMAKE_CURRENT_SOURCE_DIR</code>是<code>CMake</code>内置变量，指向当前<code>CMakeLists.txt</code>文件所在的路径。</p>
<p><code>CMAKE_CURRENT_BINARY_DIR</code>也是<code>CMake</code>内置变量，指向与当前<code>CMakeLists.txt</code>文件对应的构建目录。</p>
<p>上述命令会从<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/views</code>目录下，递归的查找<code>.csp文件</code>，并且生成同名的<code>.cc</code>和<code>.h</code>文件，存放在当前构建目录下，防止污染源代码树。</p>
<h4 id="6-4-简单的例子"><a href="#6-4-简单的例子" class="headerlink" title="6.4 简单的例子"></a>6.4 简单的例子</h4><p>我们现在做一个简单的例子，把浏览器发来的<code>Http</code>请求参数显示在返回的<code>html</code>页面中，这里直接用<code>drogon.app</code>定义<code>handler</code>，在<code>main</code>文件中，在<code>drogon::app</code>调用<code>run</code>方法之前加入如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drogon::app().registerHandler(<span class="string">&quot;/list_para&quot;</span>, [=](<span class="keyword">const</span> HttpRequestPtr &amp;req, std::function&lt;<span class="keyword">void</span> (<span class="keyword">const</span> HttpResponsePtr &amp;)&gt; &amp;&amp;callback)</span><br><span class="line">    &#123;</span><br><span class="line">        auto para=req-&gt;getParameters();</span><br><span class="line">        HttpViewData data;</span><br><span class="line">        data.insert(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;ListParameters&quot;</span>);</span><br><span class="line">        data.insert(<span class="string">&quot;parameters&quot;</span>,para);</span><br><span class="line">        auto resp=HttpResponse::newHttpViewResponse(<span class="string">&quot;ListParameters.csp&quot;</span>,data);</span><br><span class="line">        callback(resp);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上面这段代码把一个<code>lambda表达式handler</code>注册到<code>/list_para</code>路径上，获取请求的参数传递给视图显示。</p>
<p>在工程<code>views</code>文件夹下新建<code>ListParameters.csp</code>文件，内容如下：</p>
<figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!-- @@就是从控制器中传入的变量，比如是newHttpViewResponse 中的第二个HttpViewData对象 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;%c++</span><br><span class="line">    auto para=@@.get&lt;std::unordered_map&lt;std::string,std::string,utils::internal::SafeStringHash&gt;&gt;(&quot;parameters&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;[[ title ]]&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%c++ if(para.size()&gt;0)&#123;%&gt;</span><br><span class="line">    &lt;H1&gt;Parameters&lt;/H1&gt;</span><br><span class="line">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;name&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;value&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;%c++ for(auto iter:para)&#123;%&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&#123;%iter.first%&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;%c++ $$&lt;&lt;iter.second;%&gt;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;%c++&#125;%&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;%c++ &#125;else&#123;%&gt;</span><br><span class="line">    &lt;H1&gt;no parameter&lt;/H1&gt;</span><br><span class="line">    &lt;%c++&#125;%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新执行<code>cmake</code>命令并执行相应的构建命令，可以看到在当前构建目录下，会生成<code>ListParameters.h</code>和<code>ListParameters.cc</code>文件，之后运行可执行程序，在浏览器或其他客户端输入<code>http://localhost/list_para?p1=a&amp;p2=b&amp;p3=c</code>，记设置你的程序中<code>http</code>服务实际监听的端口，即可看到如下界面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251103100836513.png" alt="image-20251103100836513"></p>
<h3 id="七、会话"><a href="#七、会话" class="headerlink" title="七、会话"></a>七、会话</h3><h4 id="7-1-会话的概念"><a href="#7-1-会话的概念" class="headerlink" title="7.1 会话的概念"></a>7.1 会话的概念</h4><p><code>会话（Session）</code>是<code>web</code>应用的重要概念，用于在服务端保存客户端的状态，一般和浏览器的<code>cookie</code>配合，<code>drogon</code>提供了对会话的支持。<code>drogon</code><strong>默认关闭</strong>会话选择，你也可以通过如下接口关闭或打开：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">disableSession</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enableSession</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> timeout=<span class="number">0</span>, Cookie::SameSite sameSite=Cooie::SameSite::kNull)</span></span>;CopyErrorCopied</span><br></pre></td></tr></table></figure>

<p>都是通过<code>HttpAppFramework</code>单例调用，<code>timeout</code>参数代表了会话失效的时间，单位是秒，框架默认值是<code>1200</code>，即如果用户<code>20</code>分钟以上没有访问应用，则他对应的会话就失效了。<code>timeout</code>设置为<code>0</code>表示<code>drogon</code>将在整个生存期保留用户的会话；</p>
<p>打开会话特性前请确定你的客户端支持<code>cookie</code>，否则，<code>drogon</code>会为每次不含<code>SessionID</code>的请求创建新的会话，这会白白浪费内存和计算资源。</p>
<p><code>drogon</code>框架的会话支持默认是关闭的，如果不开启会话支持，框架只是简单的处理<code>http</code>请求而不会分配额外的<code>Session</code>内存。</p>
<h4 id="7-2-会话的对象"><a href="#7-2-会话的对象" class="headerlink" title="7.2 会话的对象"></a>7.2 会话的对象</h4><p><code>drogon</code>的会话对象类型是<code>drogon::Session</code>，它和<code>HttpViewData</code>非常类似，可以通过关键字存取任意类型的对象；支持并发读写。</p>
<p><code>drogon</code>框架会把会话对象放到<code>HttpRequest</code>对象里传递给用户，用户可以通过<code>HttpRequest</code>类的如下接口获取<code>Session</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SessionPtr <span class="title">session</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//获得的是Session对象的智能指针，通过它可以存取各种对象</span></span><br></pre></td></tr></table></figure>

<h4 id="7-3会话的例子"><a href="#7-3会话的例子" class="headerlink" title="7.3会话的例子"></a>7.3会话的例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个接口：设置会话值</span></span><br><span class="line">drogon::<span class="built_in">app</span>().<span class="built_in">registerHandler</span>(<span class="string">&quot;/setSession&quot;</span>, [](<span class="type">const</span> drogon::HttpRequestPtr &amp;req, std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> drogon::HttpResponsePtr &amp;)&gt; &amp;&amp;callback) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> session = req-&gt;<span class="built_in">session</span>();  <span class="comment">// 获取当前会话对象</span></span><br><span class="line">    session-&gt;<span class="built_in">insert</span>(<span class="string">&quot;username&quot;</span>, std::<span class="built_in">string</span>(<span class="string">&quot;Alice&quot;</span>));  <span class="comment">// 保存到会话中</span></span><br><span class="line">    <span class="keyword">auto</span> resp = drogon::HttpResponse::<span class="built_in">newHttpResponse</span>();</span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(<span class="string">&quot;Session &#x27;username&#x27; set to Alice&quot;</span>);</span><br><span class="line">    <span class="built_in">callback</span>(resp);</span><br><span class="line">&#125;,&#123;drogon::Get&#125;);  <span class="comment">// GET请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个接口：读取会话值</span></span><br><span class="line">drogon::<span class="built_in">app</span>().<span class="built_in">registerHandler</span>(<span class="string">&quot;/getSession&quot;</span>, [](<span class="type">const</span> drogon::HttpRequestPtr &amp;req, std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> drogon::HttpResponsePtr &amp;)&gt; &amp;&amp;callback) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> session = req-&gt;<span class="built_in">session</span>();</span><br><span class="line">    std::string username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (session-&gt;<span class="built_in">find</span>(<span class="string">&quot;username&quot;</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        username = session-&gt;<span class="built_in">get</span>&lt;std::string&gt;(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        username = <span class="string">&quot;(not set)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> resp = drogon::HttpResponse::<span class="built_in">newHttpResponse</span>();</span><br><span class="line">    resp-&gt;<span class="built_in">setBody</span>(<span class="string">&quot;Current session username = &quot;</span> + username);</span><br><span class="line">    <span class="built_in">callback</span>(resp);</span><br><span class="line">&#125;, &#123;drogon::Get&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码注册了两个路径<code>setSession</code>和<code>getSession</code>，下面我们通过<code>Postman</code>去访问以下这两个URL：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251103110703025.png" alt="image-20251103110703025"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251103111357464.png" alt="image-20251103111357464"></p>
<p>可以看到服务端返回的响应中，响应头有字段<code>Set-Cookie</code>，响应体也是我们服务端锁返回的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20251103111137481.png" alt="image-20251103111137481"></p>
<p>可以看到在请求头中设置了<code>Cookie</code>字段，是通过<code>setSession</code>请求服务端返回的，服务端使用通过查找到该会话，成功获取到该会话设置的数据。</p>
<h3 id="八、数据库"><a href="#八、数据库" class="headerlink" title="八、数据库"></a>八、数据库</h3><h3 id="九、插件"><a href="#九、插件" class="headerlink" title="九、插件"></a>九、插件</h3><h4 id="9-1-插件的概念"><a href="#9-1-插件的概念" class="headerlink" title="9.1 插件的概念"></a>9.1 插件的概念</h4><ul>
<li>插件可以帮助用户构建复杂的应用，在<code>Drogon</code>中，所有的插件都由框架根据配置文件统一构建并安装到应用程序中。<code>Drogon</code>中的插件都是单实例的，用户可以用插件实现任何他们想要的功能。</li>
</ul>
<h4 id="9-2-插件的创建定义"><a href="#9-2-插件的创建定义" class="headerlink" title="9.2 插件的创建定义"></a>9.2 插件的创建定义</h4><p>我们可以使用<code>drogon_ctl create plugin &lt;[namespace::]class_name&gt; //create a plugin named class_name</code>命令去创建插件</p>
<h3 id="十、配置文件"><a href="#十、配置文件" class="headerlink" title="十、配置文件"></a>十、配置文件</h3><h3 id="十一、drogon-ctl-命令"><a href="#十一、drogon-ctl-命令" class="headerlink" title="十一、drogon_ctl 命令"></a>十一、drogon_ctl 命令</h3><h3 id="十二、性能测试"><a href="#十二、性能测试" class="headerlink" title="十二、性能测试"></a>十二、性能测试</h3><h3 id="十三、Redis"><a href="#十三、Redis" class="headerlink" title="十三、Redis"></a>十三、Redis</h3><h3 id="十四、测试框架"><a href="#十四、测试框架" class="headerlink" title="十四、测试框架"></a>十四、测试框架</h3></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/')">Hexo</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="Support Author"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>Donate</div><div class="reward-main"><div class="reward-all"><span class="reward-title">Thanks for your support</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">Supporters</div><div class="reward-dec">Your support motivates me to write more 🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Hexo&amp;url=http://example.com/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/02/09/hello-world/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/2026/02/09/my-first/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">欢迎来到我的博客</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Drogon-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">Drogon 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Drogon-%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">一、Drogon 框架是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Windows-%E5%B9%B3%E5%8F%B0-Drogon-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">二、Windows 平台 Drogon 框架的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-vcpkg-%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 vcpkg 的安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Drogon-%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">三、Drogon 框架基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 控制器的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 控制器的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 控制器的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 控制器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-HttpSimpleController"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">4.3.1 HttpSimpleController</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-HttpController"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">4.3.2 HttpController</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-WebSocketController"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">4.3.3 WebSocketController</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">五、中间件和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 中间件和过滤器的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 内置中间件和过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 自定义中间件和过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 中间件的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 过滤器的定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E7%8B%AC%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 中间件单独测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8D%95%E7%8B%AC%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 过滤器单独测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 中间件和过滤器混合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 中间件和过滤器的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%A7%86%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">六、视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 视图的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-drogon-%E7%9A%84-csp-%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 drogon 的 csp 的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 视图的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 简单的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.7.</span> <span class="toc-text">七、会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E4%BC%9A%E8%AF%9D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 会话的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 会话的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E4%BC%9A%E8%AF%9D%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3会话的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.8.</span> <span class="toc-text">八、数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8F%92%E4%BB%B6"><span class="toc-number">1.9.</span> <span class="toc-text">九、插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 插件的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E6%8F%92%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AE%9A%E4%B9%89"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 插件的创建定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.10.</span> <span class="toc-text">十、配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81drogon-ctl-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.11.</span> <span class="toc-text">十一、drogon_ctl 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">1.12.</span> <span class="toc-text">十二、性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Redis"><span class="toc-number">1.13.</span> <span class="toc-text">十三、Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">1.14.</span> <span class="toc-text">十四、测试框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/09/my-first/" title="欢迎来到我的博客">欢迎来到我的博客</a><time datetime="2026-02-09T02:00:00.000Z" title="Created 2026-02-09 10:00:00">2026-02-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/09/Drogon%E6%A1%86%E6%9E%B6/" title="No title">No title</a><time datetime="2026-02-09T01:50:17.589Z" title="Created 2026-02-09 09:50:17">2026-02-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/09/hello-world/" title="Hello World">Hello World</a><time datetime="2026-02-09T01:32:43.729Z" title="Created 2026-02-09 09:32:43">2026-02-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2026 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">博客<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%A7%8B/" style="font-size: 0.88rem;">开始<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.7.1",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>